"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapStaticSnapshots = mapStaticSnapshots;
exports.serve = serve;
exports.snapshotMatches = snapshotMatches;
exports.withDefaults = withDefaults;

var _path = _interopRequireDefault(require("path"));

var pathToRegexp = _interopRequireWildcard(require("path-to-regexp"));

var _picomatch = _interopRequireDefault(require("picomatch"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// used to deserialize regular expression strings
const RE_REGEXP = /^\/(.+)\/(\w+)?$/; // Throw a better error message for invalid urls

function validURL(url, base) {
  try {
    return new URL(url, base);
  } catch (e) {
    throw new Error(`Invalid URL: ${e.input}`);
  }
} // Mutates an options object to have normalized and default values


function withDefaults(options, {
  host
}) {
  var _options;

  // allow URLs as the only option
  if (typeof options === 'string') options = {
    url: options
  }; // validate URLs

  let url = validURL(options.url, host); // default name to the url path

  (_options = options).name || (_options.name = `${url.pathname}${url.search}${url.hash}`); // normalize the snapshot url

  options.url = url.href;
  return options;
}

function mapRewrites(map, arr) {
  return Object.entries(map).reduce((r, [source, destination]) => {
    return (r || []).concat({
      source,
      destination
    });
  }, arr);
} // Serves a static directory with the provided options and returns an object containing adjusted
// rewrites (combined with any baseUrl), the server host, a close method, and the server
// instance. The `dryRun` option will prevent the server from actually starting.


async function serve(dir, {
  dryRun,
  baseUrl,
  cleanUrls,
  rewrites = {}
}) {
  let host = 'http://localhost'; // map rewrite options with any base-url

  rewrites = mapRewrites(rewrites, baseUrl && [{
    source: _path.default.posix.join(baseUrl, '/:path*'),
    destination: '/:path*'
  }]); // start the server

  let server = !dryRun && (await new Promise(resolve => {
    let server = require('http').createServer((req, res) => {
      require('serve-handler')(req, res, {
        public: dir,
        cleanUrls,
        rewrites
      });
    }).listen(() => resolve(server));
  })); // easy clean up

  let close = () => {
    if (server) {
      return new Promise(resolve => {
        server.close(resolve);
      });
    }
  }; // add the port to the host and return


  if (server) host += `:${server.address().port}`;
  return {
    host,
    rewrites,
    server,
    close
  };
} // Returns true or false if a snapshot matches the provided include and exclude predicates. A
// predicate can be an array of predicates, a regular expression, a glob pattern, or a function.


function snapshotMatches(snapshot, include, exclude) {
  if (!include && !exclude) return true;

  let test = (predicate, fallback) => {
    if (predicate && typeof predicate === 'string') {
      // snapshot matches a glob
      let result = (0, _picomatch.default)(predicate, {
        basename: true
      })(snapshot.name); // snapshot might match a string pattern

      if (!result) {
        try {
          let [, parsed = predicate, flags] = RE_REGEXP.exec(predicate) || [];
          result = new RegExp(parsed, flags).test(snapshot.name);
        } catch (e) {}
      }

      return result;
    } else if (predicate instanceof RegExp) {
      // snapshot matches a regular expression
      return predicate.test(snapshot.name);
    } else if (typeof predicate === 'function') {
      // advanced matching
      return predicate(snapshot);
    } else if (Array.isArray(predicate) && predicate.length) {
      // array of predicates
      return predicate.some(p => test(p));
    } else {
      // default fallback
      return fallback;
    }
  }; // not excluded or explicitly included


  return !test(exclude, false) && test(include, true);
} // Maps an array of snapshots or paths to options ready to pass along to the core snapshot
// method. Paths are normalized before overrides are conditionally applied via their own include and
// exclude options. Snapshot URLs are then rewritten accordingly before default options are applied,
// including prepending the appropriate host. The returned set of snapshot options are sorted and
// filtered by the top-level include and exclude options.


function mapStaticSnapshots(snapshots, {
  host,
  include,
  exclude,
  cleanUrls,
  rewrites = [],
  overrides = [],
  server
} = {}) {
  var _server$host, _server$rewrites;

  // prioritize server properties
  host = (_server$host = server === null || server === void 0 ? void 0 : server.host) !== null && _server$host !== void 0 ? _server$host : host;
  rewrites = (_server$rewrites = server === null || server === void 0 ? void 0 : server.rewrites) !== null && _server$rewrites !== void 0 ? _server$rewrites : mapRewrites(rewrites, []); // reduce rewrites into a single function

  let applyRewrites = [{
    test: url => !/^(https?:\/)?\//.test(url) && url,
    rewrite: url => _path.default.posix.normalize(_path.default.posix.join('/', url))
  }, ...rewrites.map(({
    source,
    destination
  }) => ({
    test: pathToRegexp.match(destination),
    rewrite: pathToRegexp.compile(source)
  })), {
    test: url => cleanUrls && url,
    rewrite: url => url.replace(/(\/index)?\.html$/, '')
  }].reduceRight((apply, {
    test,
    rewrite
  }) => snap => {
    var _snap$url, _res$params;

    let res = test((_snap$url = snap.url) !== null && _snap$url !== void 0 ? _snap$url : snap);
    if (res) snap = rewrite((_res$params = res.params) !== null && _res$params !== void 0 ? _res$params : res);
    return apply(snap);
  }, s => s); // reduce overrides into a single function

  let applyOverrides = overrides.reduceRight((apply, {
    include,
    exclude,
    ...opts
  }) => snap => {
    if (snapshotMatches(snap, include, exclude)) Object.assign(snap, opts);
    return apply(snap);
  }, s => s); // sort and reduce snapshots with overrides

  return [...snapshots].sort().reduce((snapshots, snap) => {
    snap = withDefaults(applyRewrites(snap), {
      host
    });
    return snapshotMatches(snap, include, exclude) ? snapshots.concat(applyOverrides(snap)) : snapshots;
  }, []);
}