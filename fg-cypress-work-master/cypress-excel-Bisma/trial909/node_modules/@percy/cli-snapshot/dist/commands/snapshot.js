"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Snapshot = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _config = _interopRequireDefault(require("@percy/config"));

var _cliCommand = _interopRequireWildcard(require("@percy/cli-command"));

var _request = _interopRequireDefault(require("@percy/client/dist/request"));

var _core = _interopRequireDefault(require("@percy/core"));

var _logger = _interopRequireDefault(require("@percy/logger"));

var _globby = _interopRequireDefault(require("globby"));

var _yaml = _interopRequireDefault(require("yaml"));

var _package = _interopRequireDefault(require("../../package.json"));

var _utils = require("../utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Snapshot extends _cliCommand.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "log", (0, _logger.default)('cli:snapshot'));
  }

  async run() {
    // skip snapshots
    if (!this.isPercyEnabled()) {
      return this.log.info('Percy is disabled. Skipping snapshots');
    }

    let {
      'dir|file|sitemap': arg
    } = this.args;
    let isSitemap = /^https?:\/\//.test(arg); // validate directory or file existence

    if (!isSitemap && !_fs.default.existsSync(arg)) this.error(`Not found: ${arg}`);

    let isStatic = !isSitemap && _fs.default.lstatSync(arg).isDirectory(); // initialize percy


    this.percy = new _core.default({ ...this.percyrc({
        [isSitemap ? 'sitemap' : 'static']: isSitemap || isStatic ? {
          include: this.flags.include,
          exclude: this.flags.exclude
        } : undefined
      }),
      clientInfo: `${_package.default.name}/${_package.default.version}`,
      environmentInfo: `node/${process.version}`,
      server: false
    }); // gather snapshots

    let snapshots = isSitemap && (await this.loadSitemapSnapshots(arg)) || isStatic && (await this.loadStaticSnapshots(arg)) || (await this.loadSnapshotsFile(arg));

    if (!snapshots.length) {
      this.error('No snapshots found');
    } // start processing snapshots


    await this.percy.start();
    this.percy.snapshot(snapshots);
  } // Called on error, interupt, or after running


  async finally(error) {
    var _this$percy, _this$server;

    await ((_this$percy = this.percy) === null || _this$percy === void 0 ? void 0 : _this$percy.stop(!!error));
    await ((_this$server = this.server) === null || _this$server === void 0 ? void 0 : _this$server.close());
  } // Fetches and maps sitemap URLs to snapshots.


  async loadSitemapSnapshots(sitemap) {
    let config = this.percy.config.sitemap; // fetch sitemap URLs

    let urls = await (0, _request.default)(sitemap, (body, res) => {
      // validate sitemap content-type
      let [contentType] = res.headers['content-type'].split(';');

      if (!/^(application|text)\/xml$/.test(contentType)) {
        this.error('The sitemap must be an XML document, ' + `but the content-type was "${contentType}"`);
      } // parse XML content into a list of URLs


      let urls = body.match(/(?<=<loc>)(.*)(?=<\/loc>)/ig); // filter out duplicate URLs that differ by a trailing slash

      return urls.filter((url, i) => {
        let match = urls.indexOf(url.replace(/\/$/, ''));
        return match === -1 || match === i;
      });
    }); // map with inherited static options

    return (0, _utils.mapStaticSnapshots)(urls, config);
  } // Serves a static directory and returns a list of snapshots.


  async loadStaticSnapshots(dir) {
    let config = this.percy.config.static;
    let baseUrl = this.flags['base-url'] || config.baseUrl;
    let dryRun = this.flags['dry-run']; // validate any provided base-url

    if (baseUrl && !baseUrl.startsWith('/')) {
      this.error('The base-url must begin with a forward slash (/) ' + 'when snapshotting static directories');
    } // start the server


    this.server = await (0, _utils.serve)(dir, { ...config,
      baseUrl,
      dryRun
    }); // gather paths

    let isStr = s => typeof s === 'string';

    let strOr = (a, b) => a.length && a.every(isStr) ? a : b;

    let files = strOr([].concat(config.include || []), '**/*.html');
    let ignore = strOr([].concat(config.exclude || []), []);
    let paths = await (0, _globby.default)(files, {
      cwd: dir,
      ignore
    }); // map snapshots from paths and config

    return (0, _utils.mapStaticSnapshots)(paths, { ...config,
      server: this.server
    });
  } // Loads snapshots from a js, json, or yaml file.


  async loadSnapshotsFile(file) {
    let ext = _path.default.extname(file);

    let config = {}; // load snapshots file

    if (ext === '.js') {
      config = require(_path.default.resolve(file));
      if (typeof config === 'function') config = await config();
    } else if (ext === '.json') {
      config = JSON.parse(_fs.default.readFileSync(file, {
        encoding: 'utf-8'
      }));
    } else if (ext.match(/\.ya?ml$/)) {
      config = _yaml.default.parse(_fs.default.readFileSync(file, {
        encoding: 'utf-8'
      }));
    } else {
      this.error(`Unsupported filetype: ${file}`);
    }

    let {
      // flags override config options
      'base-url': baseUrl = config.baseUrl,
      include = config.include,
      exclude = config.exclude
    } = this.flags; // validate base-url before config options

    if (baseUrl && !baseUrl.startsWith('http')) {
      this.error('The base-url must include a protocol and hostname ' + 'when providing a list of snapshots');
    } // validate snapshot config options


    let errors = _config.default.validate(config, '/snapshot/list');

    if (errors) {
      this.log.warn('Invalid snapshot options:');

      for (let e of errors) this.log.warn(`- ${e.path}: ${e.message}`);
    } // support config that only contains a list of snapshots


    return (Array.isArray(config) ? config : config.snapshots || []).reduce((snapshots, snap) => {
      // reduce matching snapshots with default options
      snap = (0, _utils.withDefaults)(snap, {
        host: baseUrl
      });
      return (0, _utils.snapshotMatches)(snap, include, exclude) ? snapshots.concat(snap) : snapshots;
    }, []);
  }

}

exports.Snapshot = Snapshot;

_defineProperty(Snapshot, "description", 'Take snapshots from a static directory, snapshots file, or sitemap url');

_defineProperty(Snapshot, "args", [{
  name: 'dir|file|sitemap',
  description: 'static directory, snapshots file, or sitemap url',
  required: true
}]);

_defineProperty(Snapshot, "flags", { ..._cliCommand.flags.logging,
  ..._cliCommand.flags.discovery,
  ..._cliCommand.flags.config,
  'base-url': _cliCommand.flags.string({
    description: 'the base url pages are hosted at when snapshotting',
    char: 'b'
  }),
  include: _cliCommand.flags.string({
    description: 'one or more globs/patterns matching snapshots to include',
    multiple: true
  }),
  exclude: _cliCommand.flags.string({
    description: 'one or more globs/patterns matching snapshots to exclude',
    multiple: true
  }),
  // static only flags
  'clean-urls': _cliCommand.flags.boolean({
    description: 'rewrite static index and filepath URLs to be clean',
    percyrc: 'static.cleanUrls'
  }),
  // deprecated flags
  files: _cliCommand.flags.string({
    deprecated: {
      map: 'include',
      until: '1.0.0'
    },
    percyrc: 'static.include',
    hidden: true
  }),
  ignore: _cliCommand.flags.string({
    deprecated: {
      map: 'exclude',
      until: '1.0.0'
    },
    percyrc: 'static.exclude',
    hidden: true
  })
});

_defineProperty(Snapshot, "examples", ['$ percy snapshot ./public', '$ percy snapshot snapshots.yml']);